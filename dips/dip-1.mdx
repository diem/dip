---
dip: 1
title: Off-chain API
authors: Kevin Hurley (@kphfb), George Danezis, SunMi Lee, Xiao Li, Dmitry Pimenov, David Wolinsky (@davidiw), Lu Zhang
status: Final
type: Informational
created: 05/29/2020
---

import useBaseUrl from '@docusaurus/useBaseUrl';

# Summary
---
The Off-Chain Protocol defines an API and payload specification that allows for the private exchange of information between two parties that cannot (easily) be achieved directly on a blockchain. This information includes the sensitive details of the parties involved in a payment that should remain off-chain. The information is exchanged within an authenticated and encrypted channel and only made available to the parties that directly involved.  Note that this API is being published by the Diem Association on an “as is” basis. Publication of this Off-Chain Protocol by the Diem Association does not mean that the Association is taking any position on whether the Off-Chain Protocol addresses issues of compliance, privacy or scalability. Users of this Off-Chain Protocol must make such determinations on their own.

# Overview
---
The two parties that participate in the off-chain protocol communicate through HTTP requests and responses within a TLS channel. Each request and response is signed via [JSON Web Signature (JWS)](https://tools.ietf.org/html/rfc7515) to ensure authenticity and integrity. Consider an example in which VASP A sends a command to VASP B:

* VASP A knows VASP B’s on-chain account and obtains the url from VASP B's `DualAttestation::Credential::base_url` resource
* VASP A connects to this endpoint and establishes a tls-encrypted HTTP channel
* VASP A sends a request across the channel
  * VASP A, first, constructs message containing a `CommandRequestObject`
  * VASP A, then, signs the message it with the Ed25519 private key that maps to the public key stored at VASP A’s `DualAttestation::Credential::compliance_public_key`
  * VASP A, finally transmits the signed message across the channel
* VASP B receives the `CommandRequestObject`
  * VASP B, first, validates the request message
  * VASP B, then, evaluates and responds to the message constructing `CommandResponseObject`
  * VASP B signs the response with the Ed25519 private key that maps to the public key stored at VASP B’s `DualAttestation::Credential::compliance_public_key`
* VASP A receives the `CommandResponseObject`, validates the response, and concludes the exchange

# Specification
---
## On-Chain Account Setup

A VASP’s on-chain account must be created and set up in accordance with the standard VASP account creation process.

Of particular note for off-chain APIs is the compliance key and base url, [DualAttestation::Credential](https://github.com/diem/diem/blob/release-1.1/language/stdlib/modules/DualAttestation.move)’s `compliance_public_key` and `base_url`. During account setup, a VASP should set their compliance key and base url which will be stored under the Parent VASP account, see [DIP-2](https://github.com/diem/dip/blob/master/dips/dip-2.md) for more information on on-chain roles.

The compliance key value is the Ed25519 key with which a VASP signs travel rule statements which are verified on-chain and all off-chain requests and responses.

The `base_url` frameowrk does not support multiplexing and should not be shared across different providers and accounts.

## HTTP End-point

Each VASP exposes an HTTPS POST end point at `https://&lt;hostname>:&lt;port>/&lt;protocol_version>/command`. The protocol_version is v2 for this iteration of the off-chain APIs.

The base url value should be the url without path `/&lt;protocol_version>/command`, e.g. `https://&lt;hostname>:&lt;port>`.

## HTTP Headers

All HTTP requests must contain:

* A header `X-REQUEST-ID` with a unique UUID (according to [RFC4122](https://tools.ietf.org/html/rfc4122) with “-”'s included) for the request, used for tracking requests and debugging. Responses must have the same string in the `X-REQUEST-ID` header value as the requests they correspond to.
* A header `X-REQUEST-SENDER-ADDRESS` with the HTTP request sender’s VASP [DIP-5](https://dip.diem.com/dip-5/) address used in the command object.

The HTTP request sender must use the compliance key of the VASP account linked with the sender's address to sign the request JWS body. The request receiver uses this address to find the appropriate compliance key to verify the signed request. For example: VASP A transfers funds to VASP B. The HTTP request A sends to B contains `X-REQUEST-SENDER-ADDRESS` as VASP A’s address.

All HTTP responses must contain:

* A header `X-REQUEST-ID` copied from the HTTP request.

The HTTP response sender must use the compliance key of the VASP account linked with the responder's address to sign the response JWS body.

## Payloads

The payloads between two endpoints must:
* Support both single Command request-responses (HTTP 1.0) and pipelined request-responses (HTTP 1.1)
* Conform to the JWS standard with Ed25119 / EdDSA cipher suite, compact encoding, and be signed with the party's on-chain compliance key
* The content within the JWS payload must be valid JSON objects
* The content type of the HTTP request/response is unspecified and may be ignored

# Request and Response

All requests between VASPs are structured as a `CommandRequestObject` and all responses are structured as a `CommandResponseObject`. The resulting request takes a form of the following (prior to JWS signing):

```
{
    "_ObjectType": "CommandRequestObject",
    "command_type": "PingCommand", // Command type
    "command": PingCommandObject(), // Object of type as specified by command_type
    "cid": "12ce83f6-6d18-0d6e-08b6-c00fdbbf085a",
}
```

A response would look like the following:

```
{
    "_ObjectType": "CommandResponseObject",
    "status": "success",
    "cid": "12ce83f6-6d18-0d6e-08b6-c00fdbbf085a"
}
```

## CommandRequestObject

All requests between VASPs are structured as a `CommandRequestObject`.

| Field 	   | Type 	| Required? 	| Description 	|
|-------	   |------	|-----------	|-------------	|
| _ObjectType  | str    | Y | Fixed value: `CommandRequestObject`|
| command_type | str    | Y | A string representing the type of Command contained in the request. |
| command      | Command object | Y | The Command to sequence. |
| cid | str    | Y     | A unique identifier for the Command. Must be a UUID according to [RFC4122](https://tools.ietf.org/html/rfc4122) with "-"'s included. |

```
{
    "_ObjectType": "CommandRequestObject",
    "command_type": CommandType,
    "command": CommandObject(),
    "cid": str,
}
```

## CommandResponseObject

All responses to a CommandRequestObject are in the form of a CommandResponseObject

| Field 	     | Type 	| Required? 	| Description 	|
|-------	     |------	|-----------	|-------------	|
| _ObjectType    | str      | Y             | The fixed string `CommandResponseObject`. |
| status         | str      | Y             | Either `success` or `failure`. |
| error          | [OffChainErrorObject](#offchainerrorobject) | N | Details of the error when status == "failure". |
| result         | Object | N | An optional JSON object that may be defined when status == "success". |
| cid            | str      | N | The Command identifier to which this is a response. Must be a UUID according to [RFC4122](https://tools.ietf.org/html/rfc4122) with "-"'s included and must match the 'cid' of the CommandRequestObject. This field must be set unless the request to which this is responding is unparseable. |

Failure:
```
{
    "_ObjectType": "CommandResponseObject",
    "error": OffChainErrorObject(),
    "status": "failure"
    "cid": str,
}
```

Success:
```
{
    "_ObjectType": "CommandResponseObject",
    "result": {},
    "status": "success",
    "cid": str,
}
```

### OffChainErrorObject {#offchainerrorobject}

Represents an error that occurred in response to a Command.

| Field   | Type 	   | Required? | Description |
|---------|------------|-----------|-------------|
| type    | str (enum) | Y         | Either "command_error" or "protocol_error". |
| field   | str        | N         | The field on which this error occurred. |
| code    | str (enum) | Y         | The error code of the corresponding error. |
| message | str        | N         | Additional details about this error. |

```
{
    "type": "protocol_error",
    "field": "cid",
    "code": "missing_field",
    "message": "",
}
```

Use type protocol_error for the errors:

1. Invalid or missing HTTP headers
2. CommandRequestObject fields validation errors (except command field value), including CommandRequestObject#command_type mismatches CommandRequestObject#command field value.

Use type command_error for the following errors:

1. Validation errors of the CommandRequestObject#command field value.
2. Internal unexpected errors.

When a validation error occurs, HTTP response status code should be 400.

When a server internal error occurs, HTTP response status code should be 500.

For example, looking up `X-REQUEST-SENDER-ADDRESS` compliance key failed due to connection failure to Diem server is considered as internal error, and server should respond 500 status code with JWS encoded CommandResponseObject.

#### List of Error Codes

The following sections list all error codes for various validations when processing an inbound command request. Depending on implementation, some validations are optional; we recommend using the error code for the validation implemented.

##### HTTP Header Validation Error Codes {#http-header-validation-error-codes}

`invalid_http_header`:

* `X-REQUEST-SENDER-ADDRESS` header value is not the request sender’s address in the command object. All command objects should have a field that is the request sender’s address. For payment objects, it is sender.address or receiver.address.
* Could not find Diem’s onchain account by the `X-REQUEST-SENDER-ADDRESS` header value.
* Could not find the compliance key of the onchain account found by the `X-REQUEST-SENDER-ADDRESS` header value.
* The compliance key found from the onchain account by `X-REQUEST-SENDER-ADDRESS` is not a valid ED25519 public key.
* `X-REQUEST-ID` is not in valid UUID format.

`missing_http_header`: missing HTTP header `X-REQUEST-ID` or `X-REQUEST-SENDER-ADDRESS`.

###### JWS Validation Error Codes {#jws-validation-error-codes}

`invalid_jws`: invalid JWS format (compact) or protected header

`invalid_jws_signature`: JWS signature verification failed

###### Request Object Validation Error Codes {#request-object-validation-error-codes}

`invalid_json`: decoded JWS body is not json.

`invalid_object`: command request/response object json is not object, or the command object type does not match `command_type`.

`missing_field`: A required field contains no data or is missing.

`unknown_field`: field is unknown for an object.

`unknown_command_type`: invalid/unsupported `command_type`.

`invalid_field_value`: A field does not match the expected type, e.g., a UUID is not correctly formatted or an enum field contains an invalid value.

`invalid_recipient_signature`:

* Field `recipient_signature` value is not hex-encoded bytes.
* Field `recipient_signature` value is an invalid signature.

# Network Error Handling

In the case of network failure, the sending party for a Command is expected to re-send the Command until it gets a response from the counterparty VASP. An exponential backoff is suggested for Command re-sends.

Upon receipt of a Command that has already been processed (resulting in a success response or a Command error), the receiving side must reply with the same response as was previously issued (successful commands, or commands that fail with a command error, are idempotent). Requests that resulted in protocol errors may result in different responses.

For example:
* VASP A sends a request to VASP B which failed with an unknown network error. VASP A retries the send request to VASP B.
* VASP B receives both requests, and processes them in parallel.
* Both requests attempt to acquire a common lock. The first request that VASP A believes failed acquires the lock and the second request fails.
* VASP B successfully processes the first request and sends back a successful response, however, VASP A doesn’t receive the response due to the previous errors.
* VASP B rejects the second request due to lock contention.
* VASP A receives the failure for the second request, and later, retries the same request. If VASP B processes the request when the lock is not under contention it will respond successfully.

# PingCommand

This command serves for health checks on an off-chain service. A service receiving a PingCommand is expected to respond with a "success" response if the service is online and available.

## PingCommand Object

```
{
    "_ObjectType": "CommandRequestObject",
    "command_type": "PingCommand",
    "command": {
	    "_ObjectType": "PingCommand",
    },
    "cid": "12ce83f6-6d18-0d6e-08b6-c00fdbbf085a",
}
```

| Field 	   | Type 	| Required? 	| Description 	|
|-------	   |------	|-----------	|-------------	|
| _ObjectType  | str    | Y | Fixed value: `PingCommand` |

Upon receipt of this message, the recipient validates the message and responds back with a `CommandResponseObject`.

# JWS scheme {#jws-scheme}

All `CommandRequestObject` and `CommandResponseObject` messages exchanged on the off-chain channel between two services must be signed using a specific configuration of the JWS scheme.

The JSON Web Signature (JWS) scheme is specified in RFC 7515. Messages in the off-chain channel are signed with a specific configuration:

* The JWS Signature Scheme used is EdDSA as specified in RFC 8032 (EdDSA) and RFC 8037 (Elliptic Curve signatures for JWS).
* The JWS Serialization scheme used is Compact as specified in [Section 3.1 of RFC 7515](https://tools.ietf.org/html/rfc7515#section-3.1) 
* The Protected Header should contain the JSON object {"alg": "EdDSA"}, indicating the signature algorithm used.
* The Unprotected header must be empty

**Test Vector:**

JWK key:

```
{"crv":"Ed25519","d":"vLtWeB7kt7fcMPlk01GhGmpWYTHYqnGRZUUN72AT1K4","kty":"OKP","x":"vUfj56-5Teu9guEKt9QQqIW1idtJE4YoVirC7IVyYSk"}
```

Corresponding verification key (hex, bytes), as the 32 bytes stored on the Diem blockchain:

`"bd47e3e7afb94debbd82e10ab7d410a885b589db49138628562ac2ec85726129"` (len=64)

Sample payload message to sign (str, utf8):

`"Sample signed payload."` (len=22)

Valid JWS Compact Signature (str, utf8):

`"eyJhbGciOiJFZERTQSJ9.U2FtcGxlIHNpZ25lZCBwYXlsb2FkLg.dZvbycl2Jkl3H7NmQzL6P0_lDEW42s9FrZ8z-hXkLqYyxNq8yOlDjlP9wh3wyop5MU2sIOYvay-laBmpdW6OBQ"` (len=138)

# Versions

| Version | Revision | Link      |
|---------|----------|-----------|
| v3      | Current  | https://github.com/diem/dip/blob/main/dips/dip-1.mdx |
| v2      | 528639ba7cb727e0e81d85e3f4ec5980ae371c55 | https://github.com/diem/dip/blob/528639ba7cb727e0e81d85e3f4ec5980ae371c55/dips/dip-1.mdx |
| v1      | e82a0eb8a9dd5d498fc89bf84565cc7adae3d8ef | https://github.com/diem/dip/blob/e82a0eb8a9dd5d498fc89bf84565cc7adae3d8ef/lips/lip-1.mdx |

V3 changes:
* Move Travel rule into an [DIP-13](https://dip.diem.com/dip-13/)
* Add an optional result field to responses
* Improve statements around cid on responses
* Use must and instead of should around UUID requirements
  added to the specification as required?
* Removed example code -- should be in a guide not in a spec
* Introduce a PingCommand

V2 changes:
* Simplifications to state management:
  * Allow only one actor to send command for mutating object.
  * Removed Command `_writes` and `_reads` with object versioning - no longer needed when only a single actor can mutate an object in each object state
  * Required to set sender's kyc_data for initial PaymentCommand.
  * Required to set receiver's kyc_data and recipient signature when receiver actor's status is set to ready_for_settlement.
  * Removed payment actor StatusEnum: needs_recipient_signature and pending_review - no longer needed with updated state flow.
* Changed reference_id to use 128 bit UUID according to [RFC4122](https://tools.ietf.org/html/rfc4122).
* additional_kyc_data field is moved from KycDataObject to PaymentActorObject. Allows KycDataObject to be set once and never mutated.
* Protocol URL is changed, removed sender/receiver's address in the URL path, added X-REQUEST-SENDER-ADDRESS HTTP header for looking up JWS verification key.
* Updated corresponding example code.

# Disclaimers

THIS OFF-CHAIN PROTOCOL AND REFERENCE IMPLEMENTATION ARE PROVIDED "AS IS" WITH NO EXPRESS OR IMPLIED WARRANTIES WHATSOEVER, INCLUDING ANY WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, COMPLIANCE WITH LAW, ACCURACY, COMPLETENESS, OR NONINFRINGEMENT OF INTELLECTUAL PROPERTY RIGHTS.

The Diem Association disclaims all liability relating to this Off-Chain Protocol and to the implementation of this Off-Chain Protocol, including the reference implementation, and disclaims all liability for cost of procurement of substitute services, lost profits, loss of use, loss of data or any incidental, consequential, direct,
indirect, or special damages, whether under contract, tort, warranty or otherwise, arising in any way out of use or reliance upon this Off-Chain Protocol, the reference implementation, or any information herein.

The compliance processes described in this Off-Chain Protocol are for informational purposes only and do not reflect the specific compliance obligations of VASPs under applicable regulatory frameworks, their compliance programs, and/or standards imposed by Diem Networks.

# Copyright Notice

This documentation is made available under the Creative Commons Attribution 4.0 International (CC BY 4.0) license (available at https://creativecommons.org/licenses/by/4.0/).
